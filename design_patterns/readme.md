设计模式
---

##### 1.设计模式分三类

+ 创建型模式
+ 结构型模式
+ 行为型模式

##### 2.各类型的性质

+ 创建型模式
    + 运行机制基于对象的创建方式
    + 将对象创建的细节隔离出来
    + 代码与所创建的对象的类型无关

+ 结构型模式
    + 致力于设计出能够通过组合获得更强大功能的对象和类的结构
    + 重点是简化结构并识别类和对象之间的关系
    + 主要关注类的继承和组合

+ 行为型模式
    + 关注对象的交互以及对象的响应性
    + 对象应该能够交互，同时仍然保持松散耦合

##### 3. 具体模式说明

+ 创建者模式
    + [单例模式](1.singleton.py)
        + 经典单例模式
        + 单例模式中的懒实例化
        + 模块级别的单例模式
        + 单状态单例模式，让实例共享相同的状态
            + `__init__` 实现
            + `__new__` 实现
            + 基于元类的单例模式
        + 单例实例应用
            + 数据库应用程序
            + 基础设施状态检测程序

    + 单例模式缺点
        + 单例模式具有全局访问权限，全局变量可能在某处已经被误改
        + 可能会对同一个对象创建多个引用
        + 所有依赖于全局变量的类都会由于一个类的改变而紧密耦合为全局数据，从而在无意中影响另一个类
    + [工厂模式](2.factory_simple_factory.py)
        + 简述
            + 工厂可以帮助开发人员创建不同类型的对象，而不是直接将对象实例化
        + 优点
            + 松耦合，对象的创建可以独立于类的实现
            + 简化了客户端的实现。无需了解创建对象的类，但是照样可以使用它来创建对象。只需要知道传递的接口、方法和参数，就能创建所需类型的对象
            + 可以很容易地在工厂中添加其它类来创建其它类型的对象，而无需修改客户端代码，最简单的情况下，客户端只需传递另一个参数即可
            + 可以重用现有对象。但是，如果客户端直接创建对象的话，总是创建一个新对象
        + 工厂模式的三个变种
            + 简单工厂模式
                + 允许接口创建对象，但不会暴露对象的创建逻辑
            + 工厂方法模式
                + 允许创建接口，但使用那个类来创建对象，则是交由子类决定的
                + UML
                ![img.png](images/factory_method.png)
                  + 包含factoryMethod()方法的抽象类Creator
                  + factoryMethod()方法负责创建指定类型的对象
                  + ConcreteCreator类提供一个实现Creator抽象类的factoryMethod(),这种方法可以在运行时修改已创建的对象
                  + ConcreteCreator创建ConcreteProduct,并确保其创建的对象实现了Product类，同时为Product接口中的所有方法提供相应的实现
                  + 简言之，Creator接口的factoryMethod()方法和ConcreteCreator类共同决定了要创建Product的哪个子类
                  + 因此，工厂方法模式定义了一个接口来创建对象，但具体实例化哪个类则是由它的子类决定的
            + 抽象工厂模式
                + 能够创建一系列相关的对象而无需指定/公开其具体类的接口
                + 该模式能够提供其它工厂的对象，在其内部创建其它对象
