设计模式
---

##### 1.设计模式遵循的七个原则

+ 单一职责原则
    + 对类来说，一个类应该只负责一项职责
    + 注意事项和细节
        + 降低类的复杂度，一个类只负责一项职责
        + 提高类的可读性，可维护性
        + 降低变量引起的风险
        + 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则
        + 只有类中函数数量足够少，可以在函数级别保持单一智职责原则

+ 接口隔离原则
+ 依赖倒转（倒置）原则
+ 里氏替换原则
+ 开闭原则
+ 迪米特法则
+ 组合/聚合复用原则

##### 2.设计模式分三类

+ 创建型模式
+ 结构型模式
+ 行为型模式

##### 3.各类型的性质

+ 创建型模式
    + 运行机制基于对象的创建方式
    + 将对象创建的细节隔离出来
    + 代码与所创建的对象的类型无关

+ 结构型模式
    + 致力于设计出能够通过组合获得更强大功能的对象和类的结构
    + 重点是简化结构并识别类和对象之间的关系
    + 主要关注类的继承和组合

+ 行为型模式
    + 关注对象的交互以及对象的响应性
    + 对象应该能够交互，同时仍然保持松散耦合

##### 4. 具体模式说明

+ 创建者模式
    + [单例模式](1.singleton.py)
        + 经典单例模式
        + 单例模式中的懒实例化
        + 模块级别的单例模式
        + 单状态单例模式，让实例共享相同的状态
            + `__init__` 实现
            + `__new__` 实现
            + 基于元类的单例模式
        + 单例实例应用
            + 数据库应用程序
            + 基础设施状态检测程序

    + 单例模式缺点
        + 单例模式具有全局访问权限，全局变量可能在某处已经被误改
        + 可能会对同一个对象创建多个引用
        + 所有依赖于全局变量的类都会由于一个类的改变而紧密耦合为全局数据，从而在无意中影响另一个类
    + [工厂模式](2.factory_simple_factory.py)
        + 简述
            + 工厂可以帮助开发人员创建不同类型的对象，而不是直接将对象实例化
        + 优点
            + 松耦合，对象的创建可以独立于类的实现
            + 简化了客户端的实现。无需了解创建对象的类，但是照样可以使用它来创建对象。只需要知道传递的接口、方法和参数，就能创建所需类型的对象
            + 可以很容易地在工厂中添加其它类来创建其它类型的对象，而无需修改客户端代码，最简单的情况下，客户端只需传递另一个参数即可
            + 可以重用现有对象。但是，如果客户端直接创建对象的话，总是创建一个新对象
        + 工厂模式的三个变种
            + 简单工厂模式
                + 允许接口创建对象，但不会暴露对象的创建逻辑
            + 工厂方法模式
                + 允许创建接口，但使用哪个类来创建对象，则是交由子类决定的
                + UML
                  ![img.png](images/factory_method.png)
                    + 包含factoryMethod()方法的抽象类Creator
                    + factoryMethod()方法负责创建指定类型的对象
                    + ConcreteCreator类提供一个实现Creator抽象类的factoryMethod(),这种方法可以在运行时修改已创建的对象
                    + ConcreteCreator创建ConcreteProduct,并确保其创建的对象实现了Product类，同时为Product接口中的所有方法提供相应的实现
                    + 简言之，Creator接口的factoryMethod()方法和ConcreteCreator类共同决定了要创建Product的哪个子类
                    + 因此，工厂方法模式定义了一个接口来创建对象，但具体实例化哪个类则是由它的子类决定的
            + 抽象工厂模式
                + 提供一个接口来创建一系列相关对象，而无需指定/公开其具体类的接口
                + 该模式能够提供其它工厂的对象，在其内部创建其它对象
                + 不仅确保客户端与对象的创建相互隔离，同时还确保客户端能够使用创建的对象。但是，客户端只能通过借口访问对象

        + 工厂方法和抽象工厂的对比
        + ![img.png](images/工厂方法和抽象工厂.png)
